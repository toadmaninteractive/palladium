%% @author Igor compiler
%% @doc Compiler version: igorc 2.1.4
%% DO NOT EDIT THIS FILE - it is machine generated

-module(clickhouse_protocol).

-include_lib("stdlib/include/assert.hrl").
-include("clickhouse_protocol.hrl").

-export([
    data_type_to_json/1,
    data_type_from_json/1,
    enum_pair_to_json/1,
    enum_pair_from_json/1,
    column_def_to_json/1,
    column_def_from_json/1,
    query_statistics_to_json/1,
    query_statistics_from_json/1,
    query_result_to_json/1,
    query_result_from_json/1
]).

-export_type([
    data_type/0,
    enum_pair/0,
    type_spec/0,
    column_def/0,
    query_statistics/0,
    query_result/0
]).

-type data_type() :: 'int8' | 'int16' | 'int32' | 'int64' | 'uint8' | 'uint16' | 'uint32' | 'uint64' | 'float32' | 'float64' | 'decimal' | 'decimal32' | 'decimal64' | 'decimal128' | 'string' | 'fixed_string' | 'uuid' | 'date' | 'date_time' | 'enum8' | 'enum16' | 'array' | 'aggregate_function' | 'tuple' | 'special'.
-type enum_pair() :: #enum_pair{}.
-type type_spec() :: #type_spec{}.
-type column_def() :: #column_def{}.
-type query_statistics() :: #query_statistics{}.
-type query_result() :: #query_result{}.

-spec data_type_to_json(data_type()) -> igor_json:json_string().

data_type_to_json(int8) -> <<"int8">>;
data_type_to_json(int16) -> <<"int16">>;
data_type_to_json(int32) -> <<"int32">>;
data_type_to_json(int64) -> <<"int64">>;
data_type_to_json(uint8) -> <<"uint8">>;
data_type_to_json(uint16) -> <<"uint16">>;
data_type_to_json(uint32) -> <<"uint32">>;
data_type_to_json(uint64) -> <<"uint64">>;
data_type_to_json(float32) -> <<"float32">>;
data_type_to_json(float64) -> <<"float64">>;
data_type_to_json(decimal) -> <<"decimal">>;
data_type_to_json(decimal32) -> <<"decimal32">>;
data_type_to_json(decimal64) -> <<"decimal64">>;
data_type_to_json(decimal128) -> <<"decimal128">>;
data_type_to_json(string) -> <<"string">>;
data_type_to_json(fixed_string) -> <<"fixed_string">>;
data_type_to_json(uuid) -> <<"uuid">>;
data_type_to_json(date) -> <<"date">>;
data_type_to_json(date_time) -> <<"date_time">>;
data_type_to_json(enum8) -> <<"enum8">>;
data_type_to_json(enum16) -> <<"enum16">>;
data_type_to_json(array) -> <<"array">>;
data_type_to_json(aggregate_function) -> <<"aggregate_function">>;
data_type_to_json(tuple) -> <<"tuple">>;
data_type_to_json(special) -> <<"special">>.

-spec data_type_from_json(igor_json:json()) -> data_type().

data_type_from_json(<<"int8">>) -> int8;
data_type_from_json(<<"int16">>) -> int16;
data_type_from_json(<<"int32">>) -> int32;
data_type_from_json(<<"int64">>) -> int64;
data_type_from_json(<<"uint8">>) -> uint8;
data_type_from_json(<<"uint16">>) -> uint16;
data_type_from_json(<<"uint32">>) -> uint32;
data_type_from_json(<<"uint64">>) -> uint64;
data_type_from_json(<<"float32">>) -> float32;
data_type_from_json(<<"float64">>) -> float64;
data_type_from_json(<<"decimal">>) -> decimal;
data_type_from_json(<<"decimal32">>) -> decimal32;
data_type_from_json(<<"decimal64">>) -> decimal64;
data_type_from_json(<<"decimal128">>) -> decimal128;
data_type_from_json(<<"string">>) -> string;
data_type_from_json(<<"fixed_string">>) -> fixed_string;
data_type_from_json(<<"uuid">>) -> uuid;
data_type_from_json(<<"date">>) -> date;
data_type_from_json(<<"date_time">>) -> date_time;
data_type_from_json(<<"enum8">>) -> enum8;
data_type_from_json(<<"enum16">>) -> enum16;
data_type_from_json(<<"array">>) -> array;
data_type_from_json(<<"aggregate_function">>) -> aggregate_function;
data_type_from_json(<<"tuple">>) -> tuple;
data_type_from_json(<<"special">>) -> special.

-spec enum_pair_to_json(enum_pair()) -> igor_json:json_object().

enum_pair_to_json(Record) ->
    #enum_pair{key = VarKey, value = VarValue} = Record,
    ?assert(VarKey =/= undefined),
    ?assert(VarValue =/= undefined),
    #{
        <<"key">> => igor_json:pack(VarKey, string),
        <<"value">> => igor_json:pack(VarValue, int)
    }.

-spec enum_pair_from_json(igor_json:json_object()) -> enum_pair().

enum_pair_from_json(Json) ->
    VarKey = igor_json:parse(Json, <<"key">>, string),
    VarValue = igor_json:parse(Json, <<"value">>, int),
    #enum_pair{key = VarKey, value = VarValue}.

-spec column_def_to_json(column_def()) -> igor_json:json_object().

column_def_to_json(Record) ->
    #column_def{name = Name, type = Type} = Record,
    ?assert(Name =/= undefined),
    ?assert(Type =/= undefined),
    #{
        <<"name">> => igor_json:pack(Name, string),
        <<"type">> => igor_json:pack(Type, {custom, fun clickhouse_types:type_spec_to_json/1})
    }.

-spec column_def_from_json(igor_json:json_object()) -> column_def().

column_def_from_json(Json) ->
    Name = igor_json:parse(Json, <<"name">>, string),
    Type = igor_json:parse(Json, <<"type">>, {custom, fun clickhouse_types:type_spec_from_json/1}),
    #column_def{name = Name, type = Type}.

-spec query_statistics_to_json(query_statistics()) -> igor_json:json_object().

query_statistics_to_json(Record) ->
    #query_statistics{elapsed = Elapsed, rows_read = RowsRead, bytes_read = BytesRead} = Record,
    ?assert(Elapsed =/= undefined),
    ?assert(RowsRead =/= undefined),
    ?assert(BytesRead =/= undefined),
    #{
        <<"elapsed">> => igor_json:pack(Elapsed, double),
        <<"rows_read">> => igor_json:pack(RowsRead, long),
        <<"bytes_read">> => igor_json:pack(BytesRead, long)
    }.

-spec query_statistics_from_json(igor_json:json_object()) -> query_statistics().

query_statistics_from_json(Json) ->
    Elapsed = igor_json:parse(Json, <<"elapsed">>, double),
    RowsRead = igor_json:parse(Json, <<"rows_read">>, long),
    BytesRead = igor_json:parse(Json, <<"bytes_read">>, long),
    #query_statistics{elapsed = Elapsed, rows_read = RowsRead, bytes_read = BytesRead}.

-spec query_result_to_json(query_result()) -> igor_json:json_object().

query_result_to_json(Record) ->
    #query_result{
        meta = Meta,
        data = Data,
        rows = Rows,
        rows_before_limit_at_least = RowsBeforeLimitAtLeast,
        statistics = Statistics
    } = Record,
    ?assert(Meta =/= undefined),
    ?assert(Data =/= undefined),
    ?assert(Rows =/= undefined),
    ?assert(Statistics =/= undefined),
    #{
        <<"meta">> => igor_json:pack(Meta, {list, {custom, fun clickhouse_protocol:column_def_to_json/1}}),
        <<"data">> => igor_json:pack(Data, {list, json}),
        <<"rows">> => igor_json:pack(Rows, long),
        <<"rows_before_limit_at_least">> => igor_json:pack(RowsBeforeLimitAtLeast, long),
        <<"statistics">> => igor_json:pack(Statistics, {custom, fun clickhouse_protocol:query_statistics_to_json/1})
    }.

-spec query_result_from_json(igor_json:json_object()) -> query_result().

query_result_from_json(Json) ->
    Meta = igor_json:parse(Json, <<"meta">>, {list, {custom, fun clickhouse_protocol:column_def_from_json/1}}),
    Data = igor_json:parse(Json, <<"data">>, {list, json}),
    Rows = igor_json:parse(Json, <<"rows">>, long),
    RowsBeforeLimitAtLeast = igor_json:parse(Json, <<"rows_before_limit_at_least">>, long, undefined),
    Statistics = igor_json:parse(Json, <<"statistics">>, {custom, fun clickhouse_protocol:query_statistics_from_json/1}),
    #query_result{
        meta = Meta,
        data = Data,
        rows = Rows,
        rows_before_limit_at_least = RowsBeforeLimitAtLeast,
        statistics = Statistics
    }.

